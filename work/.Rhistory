View(df)
delay <- summarise(by_dest,
count = n(),
dist = mean(distance, na.rm = TRUE),
delay = mean(arr_delay, na.rm = TRUE))
delay <- filter(delay, count > 20, dest != "HNL")
View(delay)
ggplot(delay, aes(dist, delay)) +
geom_point(aes(size = count), alpha = 1/3) +
geom_smooth(se = FALSE)
library(ggplot2)
ggplot(delay, aes(dist, delay)) +
geom_point(aes(size = count), alpha = 1/3) +
geom_smooth(se = FALSE)
delays <- flights %>%
group_by(dest) %>%
summarise(
count = n(),
dist = mean(distance, na.rm = TRUE),
delay = mean(arr_delay, na.rm = TRUE)
) %>%
filter(count > 20, dest != "HNL")
knit_with_parameters('~/git/banana-phone/work/flu_repo.Rmd')
source('~/Google Drive/rstudio/R4ds/4_data_transformation.R', echo=TRUE)
library(dplyr)
library(ggplot2)
library(nycflights13)
flights
class(flights)
flights
class(flights)
data_frame(x = 1:3, y = c("a", "b", "c"))
df1 <- data.frame(x = 1:3, y = 3:1)
df1
class(df1[ , 1:2])
class(df1[ , 1])
df2 <- data_frame(x = 1:3, y = 3:1)
class(df2[ , 1:2])
class(df2[ , 1])
class(df2[[1]])
class(df2$x)
df2
df <- data.frame(abc = 1)
df$a
df <- data.frame(abc = 1)
df$a
df
df2 <- data_frame(abc = 1)
# subsetting a tbl_df with [ always returns another tbl_df; with a data frame, [ sometimes returns a data frame, sometimes returns a vector
df1 <- data.frame(x = 1:3, y = 3:1)
class(df1[ , 1:2])
class(df1[ , 1])
df2 <- data_frame(x = 1:3, y = 3:1)
class(df2[ , 1:2])
class(df2[ , 1])
data_frame(x = 1:3, y = c("a", "b", "c"))
df1 <- data.frame(x = 1:3, y = 3:1)
class(df1[ , 1:2])
class(df1[ , 1])
df2 <- data_frame(x = 1:3, y = 3:1)
class(df2[ , 1:2])
class(df2[ , 1])
# to extract a single column from tbl_df use [[ or $
class(df2[[1]])
class(df2$x)
# when you extract a variable with $, tbl_dfs never do partial matching
df <- data.frame(abc = 1)
df$a
df2 <- data_frame(abc = 1)
df2$a
filter(flights, month == 1, day == 1)
jan1 <- filter(flights, month == 1, day == 1)
# to both print results and save to variable, wrap in ()
(dec25 <- filter(flights, month == 12, day == 25))
filter(flights, month == 11 | month == 12)
filter(flights, month %in% c(11, 12))
df <- data_frame(x = c(1, NA, 3))
filter(df, x > 1)
filter(df, is.na(x) | x > 1)
df <- data_frame(
x = c(FALSE, TRUE, FALSE),
y = c(TRUE, FALSE, TRUE)
)
filter(df, cumany(x)) # all rows after first TRUE
df
filter(df, cumall(y)) # all rows until first FALSE
filter(flights, !(arr_delay > 120 | dep_delay > 120))
filter(flights, arr_delay <= 120, dep_delay <= 120)
df <- data_frame(x = c(1, NA, 3))
filter(df, x > 1)
df
filter(df, x > 1)
filter(df, is.na(x) | x > 1)
#' if you provide more than one column name, each additional column will be used to break ties in the values of preceding columns
arrange(flights, year, month, day)
# to re-order by a column in descending order
arrange(flights, desc(arr_delay))
# NA always at the end
df <- data_frame(x = c(5, 2, NA))
arrange(df, x)
select(flights, year, month, day)
select(flights, year:day)
select(flights, -(year:day))
select(flights, tail_num = tailnum)
# use rename() instead
rename(flights, tail_num = tailnum)
select(flights, tail_num = tailnum)
# but, use rename() instead to keep variables by default
rename(flights, tail_num = tailnum)
select(flights, tail_num = tailnum)
# but, use rename() instead to keep variables by default
rename(flights, tail_num = tailnum)
flights_sml <- select(flights,
year:day,
ends_with("delay"),
distance,
air_time
)
mutate(flights_sml,
gain = arr_delay - dep_delay,
speed = distance /air_time * 60
)
mutate(flights_sml,
gain = arr_delay - dep_delay,
hours = air_time / 60,
gain_per_hour = gain / hours
)
# if you only want to keep the new variables, use transmute():
transmute(flights,
gain = arr_delay - dep_delay,
hours = air_time / 60,
gain_per_hour = gain / hours
)
summarise(flights, delay = mean(dep_delay, na.rm = TRUE))
source('~/Google Drive/rstudio/R4ds/4_data_transformation.R', echo=TRUE)
summarise(flights, delay = mean(dep_delay, na.rm = TRUE))
by_day <- group_by(flights, year, month, day)
summarise(by_day, delay = mean(dep_delay, na.rm = TRUE))
by_dest <- group_by(flights, dest)
delay <- summarise(by_dest,
count = n(),
dist = mean(distance, na.rm = TRUE),
delay = mean(arr_delay, na.rm = TRUE))
delay <- filter(delay, count > 20, dest != "HNL")
delay
delays <- flights %>%
group_by(dest) %>%
summarise(
count = n(),
dist = mean(distance, na.rm = TRUE),
delay = mean(arr_delay, na.rm = TRUE)
) %>%
filter(count > 20, dest != "HNL")
delays
source('~/Google Drive/rstudio/R4ds/4_data_transformation.R', echo=TRUE)
detach("package:stats", unload=TRUE)
library("stats", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
delays <- not_cancelled %>%
group_by(tailnum) %>%
summarise(
delay = mean(arr_delay), n()
)
ggplot(delays, aes(delay)) +
geom_histogram(binwidth = 10)
flights %>%
group_by(year, month, day) %>%
summarise(mean = mean(dep_delay))
flights %>%
group_by(year, month, day) %>%
summarise(mean = mean(dep_delay, na.rm = TRUE))
not_cancelled <- filter(flights, !is.na(dep_delay), !is.na(arr_delay))
delays <- flights %>%
group_by(dest) %>%
summarise(
count = n(),
dist = mean(distance, na.rm = TRUE),
delay = mean(arr_delay, na.rm = TRUE)
) %>%
filter(count > 20, dest != "HNL")
source('~/Google Drive/rstudio/R4ds/4_data_transformation.R', echo=TRUE)
library(ggplot2)
source('~/Google Drive/rstudio/R4ds/4_data_transformation.R')
flights
class(flights)
source('~/Google Drive/rstudio/R4ds/4_data_transformation.R')
source('~/Google Drive/rstudio/R4ds/4_data_transformation.R', echo=TRUE)
filter(flights, month == 1, day == 1)
jan1 <- filter(flights, month == 1, day == 1)
# to both print results and save to variable, wrap in ()
(dec25 <- filter(flights, month == 12, day == 25))
library(dplyr)
library(ggplot2)
library(nycflights13)
flights
class(flights)
# make a new tbl_df from individual vectors with data_frame()
# use as.data_frame() for large data frames
data_frame(x = 1:3, y = c("a", "b", "c"))
# differences between tbl_dfs and data.frames
# subsetting a tbl_df with [ always returns another tbl_df; with a data frame, [ sometimes returns a data frame, sometimes returns a vector
df1 <- data.frame(x = 1:3, y = 3:1)
class(df1[ , 1:2])
class(df1[ , 1])
df2 <- data_frame(x = 1:3, y = 3:1)
class(df2[ , 1:2])
class(df2[ , 1])
# to extract a single column from tbl_df use [[ or $
class(df2[[1]])
class(df2$x)
# when you extract a variable with $, tbl_dfs never do partial matching
df <- data.frame(abc = 1)
df$a
df2 <- data_frame(abc = 1)
df2$a
# --- 4.2 Dplyr verbs ---
#' `arrange()`
#' `filter()`
#' `select()`
#' `mutate()`
#' `summarise()`
#' `group_by()`
# --- 4.3 filter() ---
#' Subset observations with filter()
# to select all flights on January 1
filter(flights, month == 1, day == 1)
flights
source('~/Google Drive/rstudio/R4ds/4_data_transformation.R')
# --- 4. Data transformation ---
# http://r4ds.had.co.nz/transform.html
library(dplyr)
library(ggplot2)
library(nycflights13)
flights
class(flights)
# make a new tbl_df from individual vectors with data_frame()
# use as.data_frame() for large data frames
data_frame(x = 1:3, y = c("a", "b", "c"))
# differences between tbl_dfs and data.frames
# subsetting a tbl_df with [ always returns another tbl_df; with a data frame, [ sometimes returns a data frame, sometimes returns a vector
df1 <- data.frame(x = 1:3, y = 3:1)
class(df1[ , 1:2])
class(df1[ , 1])
df2 <- data_frame(x = 1:3, y = 3:1)
class(df2[ , 1:2])
class(df2[ , 1])
# to extract a single column from tbl_df use [[ or $
class(df2[[1]])
class(df2$x)
# when you extract a variable with $, tbl_dfs never do partial matching
df <- data.frame(abc = 1)
df$a
df2 <- data_frame(abc = 1)
df2$a
# --- 4.2 Dplyr verbs ---
#' `arrange()`
#' `filter()`
#' `select()`
#' `mutate()`
#' `summarise()`
#' `group_by()`
# --- 4.3 filter() ---
#' Subset observations with filter()
# to select all flights on January 1
filter(flights, month == 1, day == 1)
#base code:
#flights[flights$month == 1 & flight$day == 1 &
#          !is.na(flights$month) & !is.na(flights$day), , drop = FALSE]
#or with base subset()function:
#subset(flights, month == 1 & day == 1)
# to save the results
jan1 <- filter(flights, month == 1, day == 1)
# to both print results and save to variable, wrap in ()
(dec25 <- filter(flights, month == 12, day == 25))
# --- 4.3.1 Comparisons
#' Numeric comparison operators: >, >=, <, <=, !=, ==
# --- 4.3.2 Logical operators
#' Multiple arguments to filter() are combined with “and”. To get more complicated expressions, you can use boolean operators yourself:
# to find flights in January
filter(flights, month == 11 | month == 12)
# instead use %in% to find flights in November and December
filter(flights, month %in% c(11, 12))
# to find flights that weren't delayed by more than two hours:
filter(flights, !(arr_delay > 120 | dep_delay > 120))
filter(flights, arr_delay <= 120, dep_delay <= 120)
#
df <- data_frame(
x = c(FALSE, TRUE, FALSE),
y = c(TRUE, FALSE, TRUE)
)
# to find all the rows after the first TRUE, or all rows until the first FALSE
filter(df, cumany(x)) # all rows after first TRUE
filter(df, cumall(y)) # all rows until first FALSE
# --- 4.3.3 Missing values ---
#' NA represents an unkonwn value so missing values are "contagious"; any operation involving an unknown value will also be unknown.
# if you want to preserve missing values, ask for them explicitly
df <- data_frame(x = c(1, NA, 3))
filter(df, x > 1)
filter(df, is.na(x) | x > 1)
# --- 4.4 arrange() ---
#' arrange() reorder rows
#' If you provide more than one column name, each additional column will be used to break ties in the values of preceding columns
arrange(flights, year, month, day)
# to re-order by a column in descending order
arrange(flights, desc(arr_delay))
# NA always at the end
df <- data_frame(x = c(5, 2, NA))
arrange(df, x)
#base code:
#flights[(flights$year, flights$month, flights$day), , drop = FALSE]
#' arrange() provides a more convenient way of sorting one variable in descending order with the desc() helper function.
# --- 4.5 select() ---
#' Select subset of columns with select()
# select columns by name
select(flights, year, month, day)
# select all columns between year and day (inclusive)
select(flights, year:day)
# select all columns except those from year to day (inclusive)
select(flights, -(year:day))
#' select() helper functions:
#' starts_with("abc"):
#' ends_with("xyz"): matches names that end with "xyz"
#' contains("ijk"): matches names that contain "ijk"
#' matches("(.)\\1") matches any variables that contain repeated characters
#' num_range("x", 1:3): matches x1, x2, and x3
#' See ?select for more details.
# select() to rename variables
select(flights, tail_num = tailnum)
# but, use rename() instead to keep variables by default
rename(flights, tail_num = tailnum)
#' The select() function works similarly to the select argument in base::subset(). select() is its own function in dplyr because the dplyr philosophy is to have small functions that each do one thing well.
# --- 4.6 mutate() ---
#' Add new columns that are functions of existing columns with mutate()
#' mutate() adds new columns at the end of your dataset, so start by creating a narrower dataset
# first create a narrower dataset
flights_sml <- select(flights,
year:day,
ends_with("delay"),
distance,
air_time
)
mutate(flights_sml,
gain = arr_delay - dep_delay,
speed = distance /air_time * 60
)
# note that you can refer to columns in mutate() that you've just created:
mutate(flights_sml,
gain = arr_delay - dep_delay,
hours = air_time / 60,
gain_per_hour = gain / hours
)
# if you only want to keep the new variables, use transmute():
transmute(flights,
gain = arr_delay - dep_delay,
hours = air_time / 60,
gain_per_hour = gain / hours
)
#' mutate() is similar to transform() in base R, but in mutate() you can refer to variables you’ve just created; in transform() you cannot.
# --- 4.6.1. useful functions ---
#' * arithmetic operators:
#' * modular arithmetic:
# for example, you can compute hour and minute from dep_time with:
transmute(flights,
dep_time,
hour = dep_time %/% 100,
minute = dep_time %/% 100
)
#' * logs: log(), log2(), log10()
#' * offsets: lead() and lag()
#' * cumulative and rolling aggregates:
#' * logical comparisons:
#' * ranking: there are a number of ranking functions, but you should start with min_rank(). It does the most usual type of ranking (e.g. 1st, 2nd, 2nd, 4th). The default gives smallest values the small ranks; use desc(x) to give the largest values the smallest ranks
y <- c(1, 2, 2, NA, 3, 4)
data_frame(
row_number(y),
min_rank(y),
dense_rank(y),
percent_rank(y),
cume_dist(y)
) %>% knitr::kable()
#' If min_rank() doesn’t do what you need, look at the variants row_number(), dense_rank(), cume_dist(), percent_rank(), ntile().
# --- 4.7 summarise() ---
#' Grouped summaries with summarise() collapses a data frame to a single row:
summarise(flights, delay = mean(dep_delay, na.rm = TRUE))
# change unit of analysis from complete dataset to individual groups
# average delay per date:
by_day <- group_by(flights, year, month, day)
summarise(by_day, delay = mean(dep_delay, na.rm = TRUE))
# --- 4.7.1. Combining multiple operators using pipe
#' To explore the relationship between distance and average delay for each location
# Method 1:
by_dest <- group_by(flights, dest)
delay <- summarise(by_dest,
count = n(),
dist = mean(distance, na.rm = TRUE),
delay = mean(arr_delay, na.rm = TRUE))
delay <- filter(delay, count > 20, dest != "HNL")
# delays increase with distance up to ~750 miles, then decrease
# plot
ggplot(delay, aes(dist, delay)) +
geom_point(aes(size = count), alpha = 1/3) +
geom_smooth(se = FALSE)
#' 3 steps to prepare this data:
#' 1. group flights by destination
#' 2. summarise to compute distance, average delay, and number of flights
#' 3. filter to remove noisy points and Honolulu airport, which is almost twice as far away as the next closest airport
# Method 2: use pipe %>% ("then")
delays <- flights %>%
group_by(dest) %>%
summarise(
count = n(),
dist = mean(distance, na.rm = TRUE),
delay = mean(arr_delay, na.rm = TRUE)
) %>%
filter(count > 20, dest != "HNL")
#' Behind the scenes, x %>% f(y) turns into f(x, y), and x %>% f(y) %>% g(z) turns into g(f(x, y), z) and so on. You can use the pipe to rewrite multiple operations in a way that you can read left-to-right, top-to-bottom
# --- 4.7.2 missing values ---
#' What happens when we don't set na.rm argument?
flights %>%
group_by(year, month, day) %>%
summarise(mean = mean(dep_delay))
flights %>%
group_by(year, month, day) %>%
summarise(mean = mean(dep_delay, na.rm = TRUE))
#' In this case, where missing values represent cancelled flights, we could also tackle the problem by first removing the cancelled flights:
not_cancelled <- filter(flights, !is.na(dep_delay), !is.na(arr_delay))
not_cancelled %>%
group_by(year, month, day) %>%
summarise(mean = mean(dep_delay))
# --- 4.7.3 counts ---
#' Whenever you do any aggregation, it’s always a good idea to include either a count (n()), or a count of non-missing values (sum(!is.na(x))). That way you can check that you’re not drawing conclusions based on very small amounts of non-missing data.
# planes that have the highest average delays
delays <- not_cancelled %>%
group_by(tailnum) %>%
summarise(
delay = mean(arr_delay), n()
)
ggplot(delays, aes(delay)) +
geom_histogram(binwidth = 10)
delays <- not_cancelled %>%
group_by(tailnum) %>%
summarise(
delay = mean(arr_delay, na.rm = TRUE),
n = n()
)
ggplot(delays, aes(n, delay)) +
geom_point()
delays %>%
filter(n > 25) %>%
ggplot(aes(n, delay)) +
geom_point()
library(tidyr)
library(dplyr)
library(DSR)
install.packages("DSR")
library(DSR)
dplyr::select()
delays <- not_cancelled %>%
group_by(tailnum) %>%
summarise(
delay = mean(arr_delay), n()
)
source('~/Google Drive/rstudio/r4ds/4_data_transformation.R')
delays <- not_cancelled %>%
group_by(tailnum) %>%
summarise(
delay = mean(arr_delay), n()
)
delays
ggplot(delays, aes(delay)) +
geom_histogram(binwidth = 10)
delays <- not_cancelled %>%
group_by(tailnum) %>%
summarise(
delay = mean(arr_delay, na.rm = TRUE),
n = n()
)
ggplot(delays, aes(n, delay)) +
geom_point()
delays
install.packages(c("lazyeval", "plyr", "tidyr"))
install.packages("foreign")
install.packages("jsonlite")
install.packages("ggthemes")
install.packages(c("plyr", "reshape2", "gridExtra"))
install.packages("survey")
setwd("~/git/banana-phone/work")
library(dplyr)
library(tidyr)
library(ggplot2)
library(psych)
data_W <- read.csv("data/surveydata.csv", na = c("#NULL!", "", "Refused"), stringsAsFactors = FALSE)
data_UNW <- read.csv("data/surveydata_unw.csv", na = c("#NULL!", "", "Refused"), stringsAsFactors = FALSE)
# source("data_cleaning.R")
load("clean/all.Rdata")
# set new names
names(data2) <- new_name
# Q1 tables
with(data2, table(Q1))
data2 %>%
count(Q1)
with(data_UNW, table(Q1))
data_UNW %>%
count(Q1)
with(data2, table(Q2))
data2 %>%
count(Q2)
with(data2, table(Q2))
data2 %>%
count(Q2)
with(data_UNW, table(Q2))
data_UNW %>%
count(Q2)
